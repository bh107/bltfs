// Code generated by protoc-gen-go. DO NOT EDIT.
// source: bltfs.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	bltfs.proto

It has these top-level messages:
	Index
	Directory
	File
	Entry
	Extent
	Log
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type Entry_Op int32

const (
	Entry_UNKNOWN Entry_Op = 0
	Entry_ADD     Entry_Op = 1
	Entry_RM      Entry_Op = 2
	Entry_CH      Entry_Op = 3
)

var Entry_Op_name = map[int32]string{
	0: "UNKNOWN",
	1: "ADD",
	2: "RM",
	3: "CH",
}
var Entry_Op_value = map[string]int32{
	"UNKNOWN": 0,
	"ADD":     1,
	"RM":      2,
	"CH":      3,
}

func (x Entry_Op) String() string {
	return proto1.EnumName(Entry_Op_name, int32(x))
}
func (Entry_Op) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

// log entry class
type Log_Class int32

const (
	Log_UNKNOWN Log_Class = 0
	Log_INC     Log_Class = 1
	Log_DIFF    Log_Class = 2
)

var Log_Class_name = map[int32]string{
	0: "UNKNOWN",
	1: "INC",
	2: "DIFF",
}
var Log_Class_value = map[string]int32{
	"UNKNOWN": 0,
	"INC":     1,
	"DIFF":    2,
}

func (x Log_Class) String() string {
	return proto1.EnumName(Log_Class_name, int32(x))
}
func (Log_Class) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

// An Index is a binary index with a rooted directory structure
type Index struct {
	// A pointer to the block of the previous entry
	Prev  uint64 `protobuf:"varint,1,opt,name=prev" json:"prev,omitempty"`
	Block uint64 `protobuf:"varint,2,opt,name=block" json:"block,omitempty"`
	// The root directory entry
	Root *Entry `protobuf:"bytes,3,opt,name=root" json:"root,omitempty"`
}

func (m *Index) Reset()                    { *m = Index{} }
func (m *Index) String() string            { return proto1.CompactTextString(m) }
func (*Index) ProtoMessage()               {}
func (*Index) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Index) GetPrev() uint64 {
	if m != nil {
		return m.Prev
	}
	return 0
}

func (m *Index) GetBlock() uint64 {
	if m != nil {
		return m.Block
	}
	return 0
}

func (m *Index) GetRoot() *Entry {
	if m != nil {
		return m.Root
	}
	return nil
}

// A directory consists of a number fo entries.
type Directory struct {
	Entries []*Entry `protobuf:"bytes,2,rep,name=entries" json:"entries,omitempty"`
}

func (m *Directory) Reset()                    { *m = Directory{} }
func (m *Directory) String() string            { return proto1.CompactTextString(m) }
func (*Directory) ProtoMessage()               {}
func (*Directory) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Directory) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// A file has a length a a number of extents.
type File struct {
	Length  uint64    `protobuf:"varint,1,opt,name=length" json:"length,omitempty"`
	Extents []*Extent `protobuf:"bytes,2,rep,name=extents" json:"extents,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto1.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *File) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *File) GetExtents() []*Extent {
	if m != nil {
		return m.Extents
	}
	return nil
}

// An entry has an id, metadata and contains either a File or a Directory.
type Entry struct {
	Id         uint64   `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Name       string   `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Readonly   bool     `protobuf:"varint,3,opt,name=readonly" json:"readonly,omitempty"`
	CreateTime int64    `protobuf:"varint,4,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	ChangeTime int64    `protobuf:"varint,5,opt,name=change_time,json=changeTime" json:"change_time,omitempty"`
	ModifyTime int64    `protobuf:"varint,6,opt,name=modify_time,json=modifyTime" json:"modify_time,omitempty"`
	AccessTime int64    `protobuf:"varint,7,opt,name=access_time,json=accessTime" json:"access_time,omitempty"`
	BackupTime int64    `protobuf:"varint,8,opt,name=backup_time,json=backupTime" json:"backup_time,omitempty"`
	Operation  Entry_Op `protobuf:"varint,9,opt,name=operation,enum=proto.Entry_Op" json:"operation,omitempty"`
	// Types that are valid to be assigned to Elem:
	//	*Entry_File
	//	*Entry_Dir
	Elem isEntry_Elem `protobuf_oneof:"elem"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto1.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isEntry_Elem interface {
	isEntry_Elem()
}

type Entry_File struct {
	File *File `protobuf:"bytes,10,opt,name=file,oneof"`
}
type Entry_Dir struct {
	Dir *Directory `protobuf:"bytes,11,opt,name=dir,oneof"`
}

func (*Entry_File) isEntry_Elem() {}
func (*Entry_Dir) isEntry_Elem()  {}

func (m *Entry) GetElem() isEntry_Elem {
	if m != nil {
		return m.Elem
	}
	return nil
}

func (m *Entry) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Entry) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Entry) GetReadonly() bool {
	if m != nil {
		return m.Readonly
	}
	return false
}

func (m *Entry) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *Entry) GetChangeTime() int64 {
	if m != nil {
		return m.ChangeTime
	}
	return 0
}

func (m *Entry) GetModifyTime() int64 {
	if m != nil {
		return m.ModifyTime
	}
	return 0
}

func (m *Entry) GetAccessTime() int64 {
	if m != nil {
		return m.AccessTime
	}
	return 0
}

func (m *Entry) GetBackupTime() int64 {
	if m != nil {
		return m.BackupTime
	}
	return 0
}

func (m *Entry) GetOperation() Entry_Op {
	if m != nil {
		return m.Operation
	}
	return Entry_UNKNOWN
}

func (m *Entry) GetFile() *File {
	if x, ok := m.GetElem().(*Entry_File); ok {
		return x.File
	}
	return nil
}

func (m *Entry) GetDir() *Directory {
	if x, ok := m.GetElem().(*Entry_Dir); ok {
		return x.Dir
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Entry) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _Entry_OneofMarshaler, _Entry_OneofUnmarshaler, _Entry_OneofSizer, []interface{}{
		(*Entry_File)(nil),
		(*Entry_Dir)(nil),
	}
}

func _Entry_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*Entry)
	// elem
	switch x := m.Elem.(type) {
	case *Entry_File:
		b.EncodeVarint(10<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.File); err != nil {
			return err
		}
	case *Entry_Dir:
		b.EncodeVarint(11<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Dir); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Entry.Elem has unexpected type %T", x)
	}
	return nil
}

func _Entry_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*Entry)
	switch tag {
	case 10: // elem.file
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(File)
		err := b.DecodeMessage(msg)
		m.Elem = &Entry_File{msg}
		return true, err
	case 11: // elem.dir
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Directory)
		err := b.DecodeMessage(msg)
		m.Elem = &Entry_Dir{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Entry_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*Entry)
	// elem
	switch x := m.Elem.(type) {
	case *Entry_File:
		s := proto1.Size(x.File)
		n += proto1.SizeVarint(10<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Entry_Dir:
		s := proto1.Size(x.Dir)
		n += proto1.SizeVarint(11<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Extent is what file consists of.
type Extent struct {
	// file id that this extent belongs to
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// the partition this extent is recorded on
	// (subject to the data placement policy)
	Partition uint32 `protobuf:"varint,2,opt,name=partition" json:"partition,omitempty"`
	// the block where this extent begins
	Block uint64 `protobuf:"varint,3,opt,name=block" json:"block,omitempty"`
	// length of the extent in bytes
	Length uint64 `protobuf:"varint,4,opt,name=length" json:"length,omitempty"`
	// byte offset to first valid byte
	Boffset uint64 `protobuf:"varint,5,opt,name=boffset" json:"boffset,omitempty"`
	// byte offset in the file where this extent
	// begins
	Offset uint64 `protobuf:"varint,6,opt,name=offset" json:"offset,omitempty"`
}

func (m *Extent) Reset()                    { *m = Extent{} }
func (m *Extent) String() string            { return proto1.CompactTextString(m) }
func (*Extent) ProtoMessage()               {}
func (*Extent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Extent) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Extent) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *Extent) GetBlock() uint64 {
	if m != nil {
		return m.Block
	}
	return 0
}

func (m *Extent) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *Extent) GetBoffset() uint64 {
	if m != nil {
		return m.Boffset
	}
	return 0
}

func (m *Extent) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

// Log is either a incremental or differential journal entry.
type Log struct {
	Class Log_Class `protobuf:"varint,1,opt,name=class,enum=proto.Log_Class" json:"class,omitempty"`
	// back pointer
	Prev uint64 `protobuf:"varint,2,opt,name=prev" json:"prev,omitempty"`
	// log block where this log entry begins
	Block uint64 `protobuf:"varint,3,opt,name=block" json:"block,omitempty"`
	// new entries (dirs and files) since the epoch.
	Entries []*Entry `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
	// new extents since the epoch.
	Extents []*Extent `protobuf:"bytes,5,rep,name=extents" json:"extents,omitempty"`
}

func (m *Log) Reset()                    { *m = Log{} }
func (m *Log) String() string            { return proto1.CompactTextString(m) }
func (*Log) ProtoMessage()               {}
func (*Log) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Log) GetClass() Log_Class {
	if m != nil {
		return m.Class
	}
	return Log_UNKNOWN
}

func (m *Log) GetPrev() uint64 {
	if m != nil {
		return m.Prev
	}
	return 0
}

func (m *Log) GetBlock() uint64 {
	if m != nil {
		return m.Block
	}
	return 0
}

func (m *Log) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *Log) GetExtents() []*Extent {
	if m != nil {
		return m.Extents
	}
	return nil
}

func init() {
	proto1.RegisterType((*Index)(nil), "proto.Index")
	proto1.RegisterType((*Directory)(nil), "proto.Directory")
	proto1.RegisterType((*File)(nil), "proto.File")
	proto1.RegisterType((*Entry)(nil), "proto.Entry")
	proto1.RegisterType((*Extent)(nil), "proto.Extent")
	proto1.RegisterType((*Log)(nil), "proto.Log")
	proto1.RegisterEnum("proto.Entry_Op", Entry_Op_name, Entry_Op_value)
	proto1.RegisterEnum("proto.Log_Class", Log_Class_name, Log_Class_value)
}

func init() { proto1.RegisterFile("bltfs.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 529 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x93, 0x61, 0x8b, 0xd3, 0x4c,
	0x10, 0xc7, 0x2f, 0xc9, 0x26, 0x69, 0x27, 0xcf, 0xf5, 0x09, 0x8b, 0x48, 0x10, 0xc1, 0x18, 0xe4,
	0xae, 0x08, 0xf6, 0xc5, 0xdd, 0x27, 0xd0, 0xd6, 0xda, 0xe2, 0xd9, 0xc2, 0xaa, 0xf8, 0x52, 0xd2,
	0x64, 0xda, 0x5b, 0x2e, 0xcd, 0x86, 0xcd, 0x2a, 0xd7, 0x2f, 0x22, 0x7e, 0x2d, 0xbf, 0x91, 0x64,
	0x37, 0x69, 0x7b, 0x54, 0xee, 0x55, 0x32, 0xff, 0xf9, 0xed, 0x30, 0xb3, 0xf3, 0x5f, 0x08, 0x56,
	0x85, 0x5a, 0xd7, 0xa3, 0x4a, 0x0a, 0x25, 0xa8, 0xab, 0x3f, 0xc9, 0x67, 0x70, 0xe7, 0x65, 0x8e,
	0xf7, 0x94, 0x02, 0xa9, 0x24, 0xfe, 0x8c, 0xac, 0xd8, 0x1a, 0x12, 0xa6, 0xff, 0xe9, 0x13, 0x70,
	0x57, 0x85, 0xc8, 0xee, 0x22, 0x5b, 0x8b, 0x26, 0xa0, 0x31, 0x10, 0x29, 0x84, 0x8a, 0x9c, 0xd8,
	0x1a, 0x06, 0x57, 0xff, 0x99, 0x7a, 0xa3, 0xf7, 0xa5, 0x92, 0x3b, 0xa6, 0x33, 0xc9, 0x35, 0xf4,
	0x27, 0x5c, 0x62, 0xa6, 0x84, 0xdc, 0xd1, 0x0b, 0xf0, 0xb1, 0x54, 0x92, 0x63, 0x1d, 0xd9, 0xb1,
	0x73, 0x72, 0xa2, 0x4b, 0x26, 0x1f, 0x80, 0x4c, 0x79, 0x81, 0xf4, 0x29, 0x78, 0x05, 0x96, 0x1b,
	0x75, 0xdb, 0xb6, 0xd2, 0x46, 0xf4, 0x12, 0x7c, 0xbc, 0x57, 0x58, 0xaa, 0xae, 0xce, 0x79, 0x57,
	0x47, 0xab, 0xac, 0xcb, 0x26, 0xbf, 0x1d, 0x70, 0x75, 0x6d, 0x3a, 0x00, 0x9b, 0xe7, 0x6d, 0x19,
	0x9b, 0xe7, 0xcd, 0x8c, 0x65, 0xba, 0x45, 0x3d, 0x4e, 0x9f, 0xe9, 0x7f, 0xfa, 0x0c, 0x7a, 0x12,
	0xd3, 0x5c, 0x94, 0xc5, 0x4e, 0x4f, 0xd4, 0x63, 0xfb, 0x98, 0xbe, 0x80, 0x20, 0x93, 0x98, 0x2a,
	0xfc, 0xae, 0xf8, 0x16, 0x23, 0x12, 0x5b, 0x43, 0x87, 0x81, 0x91, 0xbe, 0xf0, 0x2d, 0x6a, 0xe0,
	0x36, 0x2d, 0x37, 0x2d, 0xe0, 0xb6, 0x80, 0x96, 0x3a, 0x60, 0x2b, 0x72, 0xbe, 0xde, 0x19, 0xc0,
	0x33, 0x80, 0x91, 0x3a, 0x20, 0xcd, 0x32, 0xac, 0x6b, 0x03, 0xf8, 0x06, 0x30, 0x52, 0x07, 0xac,
	0xd2, 0xec, 0xee, 0x47, 0x65, 0x80, 0x9e, 0x01, 0x8c, 0xa4, 0x81, 0x37, 0xd0, 0x17, 0x15, 0xca,
	0x54, 0x71, 0x51, 0x46, 0xfd, 0xd8, 0x1a, 0x0e, 0xae, 0xfe, 0x3f, 0xbe, 0xe1, 0xd1, 0xb2, 0x62,
	0x07, 0x82, 0xbe, 0x04, 0xb2, 0xe6, 0x05, 0x46, 0xa0, 0xb7, 0x17, 0xb4, 0x64, 0x73, 0xf3, 0xb3,
	0x33, 0xa6, 0x53, 0xf4, 0x15, 0x38, 0x39, 0x97, 0x51, 0xa0, 0x89, 0xb0, 0x25, 0xf6, 0x0b, 0x9d,
	0x9d, 0xb1, 0x26, 0x9d, 0xbc, 0x06, 0x7b, 0x59, 0xd1, 0x00, 0xfc, 0xaf, 0x8b, 0x8f, 0x8b, 0xe5,
	0xb7, 0x45, 0x78, 0x46, 0x7d, 0x70, 0xde, 0x4e, 0x26, 0xa1, 0x45, 0x3d, 0xb0, 0xd9, 0xa7, 0xd0,
	0x6e, 0xbe, 0xe3, 0x59, 0xe8, 0xbc, 0xf3, 0x80, 0x60, 0x81, 0xdb, 0xe4, 0x97, 0x05, 0x9e, 0x59,
	0xd7, 0xc9, 0x6e, 0x9e, 0x43, 0xbf, 0x4a, 0xa5, 0xe2, 0x7a, 0x8c, 0x66, 0x41, 0xe7, 0xec, 0x20,
	0x1c, 0x9c, 0xe8, 0x1c, 0x3b, 0xf1, 0x60, 0x15, 0xf2, 0xc0, 0x2a, 0x11, 0xf8, 0x2b, 0xb1, 0x5e,
	0xd7, 0xa8, 0xf4, 0x4a, 0x08, 0xeb, 0xc2, 0xe6, 0x44, 0x9b, 0xf0, 0xcc, 0x09, 0x13, 0x25, 0x7f,
	0x2c, 0x70, 0x6e, 0xc4, 0x86, 0x5e, 0x80, 0x9b, 0x15, 0x69, 0x5d, 0xeb, 0xc6, 0x06, 0xfb, 0xe1,
	0x6f, 0xc4, 0x66, 0x34, 0x6e, 0x74, 0x66, 0xd2, 0xfb, 0xd7, 0x62, 0xff, 0xeb, 0xb5, 0x3c, 0xe8,
	0xf1, 0xc8, 0xfe, 0xe4, 0x11, 0xfb, 0x1f, 0xdb, 0xdb, 0x7d, 0xd4, 0xde, 0x97, 0xe0, 0xea, 0x56,
	0x4e, 0xae, 0x7e, 0xbe, 0x18, 0x87, 0x16, 0xed, 0x01, 0x99, 0xcc, 0xa7, 0xd3, 0xd0, 0x5e, 0x79,
	0xfa, 0xfc, 0xf5, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x8e, 0x8b, 0xae, 0x49, 0xf7, 0x03, 0x00,
	0x00,
}
